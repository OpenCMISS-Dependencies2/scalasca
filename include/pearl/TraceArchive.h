/****************************************************************************
**  SCALASCA    http://www.scalasca.org/                                   **
*****************************************************************************
**  Copyright (c) 1998-2016                                                **
**  Forschungszentrum Juelich GmbH, Juelich Supercomputing Centre          **
**                                                                         **
**  Copyright (c) 2009-2013                                                **
**  German Research School for Simulation Sciences GmbH,                   **
**  Laboratory for Parallel Programming                                    **
**                                                                         **
**  This software may be modified and distributed under the terms of       **
**  a BSD-style license.  See the COPYING file in the package base         **
**  directory for details.                                                 **
****************************************************************************/


/*-------------------------------------------------------------------------*/
/**
 *  @file
 *  @ingroup PEARL_base
 *  @brief   Declaration of the class TraceArchive.
 *
 *  This header file provides the declaration of the class TraceArchive and
 *  related functions.
 **/
/*-------------------------------------------------------------------------*/


#ifndef PEARL_TRACEARCHIVE_H
#define PEARL_TRACEARCHIVE_H


#include <string>

#include <pearl/Uncopyable.h>


namespace pearl
{
// --- Forward declarations -------------------------------------------------

class GlobalDefs;
class LocalIdMaps;
class LocalTrace;
class Location;
class LocationGroup;


/*-------------------------------------------------------------------------*/
/**
 *  @ingroup PEARL_base
 *  @brief   Abstract representation of a trace experiment archive.
 *
 *  The %TraceArchive class provides an abstract representation for trace
 *  experiment archives. It defines a common interface to open archives and
 *  to read their global definitions data as well as per-location event trace
 *  data, while hiding the details specific to different types of archives.
 *  Currently, the following types of experiment archives are supported:
 *  <ul>
 *      <li>
 *          Experiments using the Open Trace Format 2 (OTF2), e.g., generated
 *          by the community instrumentation and measurement infrastructure
 *          Score-P.
 *      </li>
 *      <li>
 *          Legacy experiments using the EPILOG format generated by the EPIK
 *          measurement system of the Scalasca v1 release series.
 *      </li>
 *  </ul>
 *
 *  To work with trace experiment archives, first an archive handle has to be
 *  created using the TraceArchive::open() factory method:
 *  @code
 *      pearl::TraceArchive* archive = pearl::TraceArchive::open("experiment/traces.otf2");
 *  @endcode
 *  In this example, the OTF2 experiment archive defined by the anchor file
 *  &quot;traces.otf2&quot; inside the &quot;experiment&quot; directory is
 *  opened, and a corresponding archive handle assigned to the @a archive
 *  variable which can then be used to access the archive data.
 *
 *  Now, the global definition data of the experiment can be read:
 *  @code
 *      pearl::GlobalDefs* defs = archive->getDefinitions();
 *  @endcode
 *
 *  Before any event trace data can be read from the experiment archive, the
 *  corresponding trace data container needs to be opened. Following the
 *  general PEARL usage model that each PEARL process only handles the event
 *  trace data of one target application process, the corresponding location
 *  group retrieved from the global definitions (here stored in the variable
 *  @a locGroup) is used to open the associated trace data container:
 *  @code
 *      archive->openTraceContainer(locGroup);
 *  @endcode
 *  @warning
 *      In a multi-process context (e.g., when using MPI), the call to
 *      openTraceContainer(), as well as the closeTraceContainer() call
 *      introduced below, are collective operations accross all processes!
 *
 *  Next, the event trace data of a particular location within the perviously
 *  specified location group can be read:
 *  @code
 *      pearl::LocalTrace* trace = archive->getTrace(defs, location);
 *  @endcode
 *  @attention
 *      Reading event trace data is the only archive operation that can be
 *      safely used in a multi-threaded context! All other operations on an
 *      experiment archive should only be executed by a single thread.
 *  @remark
 *      In most cases, reading the event trace data also requires loading
 *      identifier mapping tables used to convert process-local definition IDs
 *      to global definition identifiers. The two-parameter call to getTrace()
 *      as shown in the example above implicitly takes care of loading these
 *      identifier mappings. However, for debugging purposes it may be desired
 *      to separately load the identifier mapping information and the trace
 *      data. Please see the description of the getIdMaps() member function
 *      for more details.
 *
 *  Finally, the event trace container can be closed and the archive handle
 *  destroyed, which implicitly also closes the archive:
 *  @code
 *      archive->closeTraceContainer();
 *      delete archive;
 *  @endcode
 *  Note that this does neither delete the global definitions object nor any
 *  trace data objects retrieved from the archive, as both the getDefinitions()
 *  and getTrace() member functions transfer ownership of the created object
 *  to the caller.
 **/
/*-------------------------------------------------------------------------*/

class TraceArchive
    : private pearl::Uncopyable
{
    public:
        // --- Public member functions ---------------------

        /// @name Constructors & destructor
        /// @{

        /// @brief Destructor.
        ///
        /// Implicitly closes the trace experiment archive, releases all
        /// allocated resources, and destroys the handle object.
        ///
        virtual
        ~TraceArchive();

        /// @}
        /// @name Archive management
        /// @{

        /// @brief Open an experiment archive.
        ///
        /// This factory method opens the trace experiment archive specified by
        /// the given anchor file/directory @a anchorName and returns a new
        /// archive handle if successful.
        ///
        /// @param anchorName
        ///     Name of the trace experiment archive anchor file/directory
        /// @returns
        ///     Pointer to archive handle object
        ///
        static TraceArchive*
        open(const std::string& anchorName);

        /// @}
        /// @name Access archive properties
        /// @{

        /// @brief Get archive anchor name.
        ///
        /// Returns the name of the trace experiment archive anchor. Depending
        /// on the archive type, this can be the name of a file (e.g., for OTF2
        /// trace archives) or the archive directory (e.g., for EPIK trace
        /// archives).
        ///
        /// @returns
        ///     Archive anchor name
        ///
        std::string
        getAnchorName() const;

        /// @brief Get archive directory name.
        ///
        /// Returns the name of the trace experiment archive directory. If
        /// the archive anchor is a directory (e.g., for EPIK trace archives),
        /// the return value is identical to the anchor name. Otherwise (e.g.,
        /// for OTF2 trace archives), it refers to the directory where the
        /// anchor file is located.
        ///
        /// @returns
        ///     Archive directory name
        ///
        std::string
        getArchiveDirectory() const;

        /// @}
        /// @name Access global definition data
        /// @{

        /// @brief Get global definitions.
        ///
        /// Reads the global definition data from the trace experiment archive
        /// and creates a new global definitions object providing access to it.
        /// The definitions object's ownership is transferred to the caller.
        ///
        /// @returns
        ///     Pointer to global definitions object
        ///
        GlobalDefs*
        getDefinitions();

        /// @}
        /// @name Access local mapping & event trace data
        /// @{

        /// @brief Open trace data container.
        ///
        /// Opens the trace data container storing the event data of the given
        /// group of locations @a locGroup. This member function has to be
        /// called before trace data objects can be retrieved via getTrace().
        ///
        /// @warning
        ///     In a multi-process context (e.g., when using MPI), this member
        ///     function is a collective operation across all processes! As it
        ///     involves communication, there may be additional restrictions on
        ///     which thread is allowed to call it in a multi-threaded setup.
        ///
        /// @param locGroup
        ///     %LocationGroup whose trace container should be opened
        ///
        void
        openTraceContainer(const LocationGroup& locGroup);

        /// @brief Close trace data container.
        ///
        /// Closes the trace data container previously opened by a call to
        /// openTraceContainer().
        ///
        /// @warning
        ///     In a multi-process context (e.g., when using MPI), this member
        ///     function is a collective operation across all processes! As it
        ///     involves communication, there may be additional restrictions on
        ///     which thread is allowed to call it in a multi-threaded setup.
        ///
        void
        closeTraceContainer();

        /// @brief Get definition identifier mappings.
        ///
        /// @note
        ///     This method is intended for debugging purposes. It should only
        ///     be used if it is desired to load the local-to-global definition
        ///     identifier mapping data separately from the trace data.
        ///     Usually, it is sufficient to call getTrace() with the default
        ///     @a idMaps=0 argument, which will implicitly load the mapping
        ///     information.
        ///
        /// Reads the local-to-global definition identifier mapping information
        /// for the given @a location from the trace experiment archive (if
        /// available) and creates a new mapping data object. The mapping
        /// information can not be accessed directly; it is only intended to
        /// be passed as the @a idMaps argument to a call to getTrace(). The
        /// mapping data object's ownership is transferred to the caller.
        ///
        /// @note
        ///     The given @a location has to be attached to the location group
        ///     provided to the openTraceContainer() call.
        ///
        /// @param location
        ///     %Location whose mapping data should be read
        /// @returns
        ///     Pointer to mapping data object
        ///
        LocalIdMaps*
        getIdMaps(const Location& location);

        /// @brief Get trace data.
        ///
        /// Reads the event trace data for the given @a location from the trace
        /// experiment archive and creates a new trace data object providing
        /// access to it. References to definitions will be resolved using the
        /// local-to-global definition identifier mapping data provided in
        /// @a idMaps and the global definitions object @a defs, retrieved by
        /// a previous call to getDefinitions(). If @a idMaps is 0, the mapping
        /// data will be automatically read from the experiment archive. The
        /// trace data object's ownership is transferred to the caller.
        ///
        /// @note
        ///     The given @a location has to be attached to the location group
        ///     provided to the openTraceContainer() call.
        ///
        /// @note
        ///     This member function takes ownership of the mapping data object
        ///     @a idMaps and deletes it once the trace data has been read.
        ///
        /// @param defs
        ///     Global definitions object
        /// @param location
        ///     %Location whose trace data should be read
        /// @param idMaps
        ///     Pointer to identifier mapping data object. If 0, mappings will
        ///     be read from the experiment archive.
        /// @returns
        ///     Pointer to trace data object
        ///
        LocalTrace*
        getTrace(const GlobalDefs& defs,
                 const Location&   location,
                 LocalIdMaps*      idMaps = 0);

        /// @}


    protected:
        // --- Protected member functions ------------------

        /// @name Constructors & destructor
        /// @{

        /// @brief Constructor.
        ///
        /// Creates a new trace experiment archive handle and initializes its
        /// data members with the anchor file/directory name @a anchorName and
        /// the experiment archive directory name @a archiveDirectory.
        ///
        /// @param anchorName
        ///     Name of the trace experiment archive anchor file/directory
        /// @param archiveDir
        ///     Name of the trace experiment archive directory
        ///
        TraceArchive(const std::string& anchorName,
                     const std::string& archiveDir);

        /// @}


    private:
        // --- Data members --------------------------------

        /// Name of anchor file/directory
        std::string mAnchorName;

        /// Name of archive directory
        std::string mArchiveDirectory;


        // --- Private member functions & friends ----------

        // To be implemented in derived classes
        virtual void
        openArchive() = 0;

        virtual void
        openContainer(const LocationGroup& locGroup) = 0;

        virtual void
        closeContainer() = 0;

        virtual void
        readDefinitions(GlobalDefs* defs) = 0;

        virtual LocalIdMaps*
        readIdMaps(const Location& location) = 0;

        virtual void
        readTrace(const GlobalDefs& defs,
                  const Location&   location,
                  LocalIdMaps*      idMaps,
                  LocalTrace*       trace) = 0;
};
}    // namespace pearl


#endif    // !PEARL_TRACEARCHIVE_H
